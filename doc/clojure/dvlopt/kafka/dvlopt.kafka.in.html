<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>dvlopt.kafka.in documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Kafka</span> <span class="project-version">1.0.0-beta0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dvlopt</span></div></div></li><li class="depth-2"><a href="dvlopt.kafka.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kafka</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kafka.admin.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>admin</span></div></a></li><li class="depth-3 branch current"><a href="dvlopt.kafka.in.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>in</span></div></a></li><li class="depth-3"><a href="dvlopt.kafka.out.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>out</span></div></a></li><li class="depth-2"><a href="dvlopt.kstreams.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>kstreams</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kstreams.builder.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>builder</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kstreams.ctx.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ctx</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kstreams.store.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>store</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kstreams.stream.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stream</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kstreams.table.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>table</span></div></a></li><li class="depth-3"><a href="dvlopt.kstreams.topology.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>topology</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="dvlopt.kafka.in.html#var-beginning-offsets"><div class="inner"><span>beginning-offsets</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-close"><div class="inner"><span>close</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-commit-offsets"><div class="inner"><span>commit-offsets</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-commit-offsets-async"><div class="inner"><span>commit-offsets-async</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-committed-offset"><div class="inner"><span>committed-offset</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-consumer"><div class="inner"><span>consumer</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-end-offsets"><div class="inner"><span>end-offsets</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-fast-forward"><div class="inner"><span>fast-forward</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-metrics"><div class="inner"><span>metrics</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-next-offset"><div class="inner"><span>next-offset</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-offsets-for-timestamps"><div class="inner"><span>offsets-for-timestamps</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-partitions"><div class="inner"><span>partitions</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-pause"><div class="inner"><span>pause</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-paused"><div class="inner"><span>paused</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-poll"><div class="inner"><span>poll</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-poll-seq"><div class="inner"><span>poll-seq</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-poll-topic-partitions"><div class="inner"><span>poll-topic-partitions</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-register-for"><div class="inner"><span>register-for</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-registered-for"><div class="inner"><span>registered-for</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-registered-for.3F"><div class="inner"><span>registered-for?</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-resume"><div class="inner"><span>resume</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-rewind"><div class="inner"><span>rewind</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-seek"><div class="inner"><span>seek</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-topics"><div class="inner"><span>topics</span></div></a></li><li class="depth-1"><a href="dvlopt.kafka.in.html#var-unregister"><div class="inner"><span>unregister</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">dvlopt.kafka.in</h1><div class="doc"><pre class="plaintext">Kafka consumers.
</pre></div><div class="public anchor" id="var-beginning-offsets"><h3>beginning-offsets</h3><div class="usage"><code>(beginning-offsets consumer topic-partitions)</code><code>(beginning-offsets consumer topic-partitions options)</code></div><div class="doc"><pre class="plaintext">Requests a map of [topic partition] -&gt; first available offset for consumption.

This function does not change the current position of the consumer.

&lt;!&gt; Blocks forever if the topic doesn't exist and dynamic creation has been disabled server-side.


A map of options may be given :

   :dvlopt.kafka/timeout
   Cf. `dvlopt.kafka` for description of time intervals


Ex. (beginning-offsets consumer
                       [["my-topic"      0]
                        ["another-topic" 3]]
                       {:dvlopt.kafka/timeout [5 :seconds]})</pre></div></div><div class="public anchor" id="var-close"><h3>close</h3><div class="usage"><code>(close consumer)</code><code>(close consumer options)</code></div><div class="doc"><pre class="plaintext">Closes the consumer and releases all associated resources.

A map of options may be given :

  :dvlopt.kafka/timeout
   Default one is of 30 seconds.
   The consumer will try to complete pending commits and leave its consumer group. If auto-commit
   is enabled, the current offsets will be committed. If operations are not completed before the
   timeout, the consumer will be force closed.
   Cf. `dvlopt.kafka` for description of time intervals</pre></div></div><div class="public anchor" id="var-commit-offsets"><h3>commit-offsets</h3><div class="usage"><code>(commit-offsets consumer)</code><code>(commit-offsets consumer options)</code></div><div class="doc"><pre class="plaintext">Manually and synchronously commits offsets to Kafka.

The committed offsets will be used on the first fetch after every assignment and also on startup.
As such, if the user need to store offsets anywhere else, this function should not be used.


A map of options may be given :

  :dvlopt.kafka/timeout
   Cf. `dvlopt.kafka` for description of time intervals

  ::topic-partition-&gt;offset
   Map of [topic partition] -&gt; offset to commit. If none is provided, offsets from the last call to `poll` and variations
   are used.


Ex. ;; commits specific offsets

    (commit-offsets consumer
                    {:dvlopt.kafka/timeout     [5 :seconds]
                     ::topic-partition-&gt;offset {["my-topic"      0] 24
                                                ["another-topic" 3] 84})</pre></div></div><div class="public anchor" id="var-commit-offsets-async"><h3>commit-offsets-async</h3><div class="usage"><code>(commit-offsets-async consumer)</code><code>(commit-offsets-async consumer options)</code></div><div class="doc"><pre class="plaintext">Manually and asynchronously commits offsets to Kafka.

The end result is the same as `commit-offsets-sync` but the offsets will be committed on the next
trip to the server, such as calling `poll`.

Multiple calls to this function are garanteed to be sent in order and any pending async commit will happen before a new sync one.


A map of options may be given :

  ::on-committed
   Callback called when offsets are actually committed. Acceps 2 arguments : an exception in case of failure and a map of
   [topic partition] -&gt; committed offset in case of success.

  ::topic-partition-&gt;offset
   Map of [topic partition] -&gt; offset to commit. If none is provided, offsets from the last call to `poll` and variations
   are used.


Ex. (commit-offsets-async consumer
                          {::on-committed            (fn callback [exception topic-partition-&gt;offset]
                                                       (when exception
                                                         ...))
                           ::topic-partition-&gt;offset {["some_topic" 0]} 42})</pre></div></div><div class="public anchor" id="var-committed-offset"><h3>committed-offset</h3><div class="usage"><code>(committed-offset consumer [topic partition :as topic-partition])</code><code>(committed-offset consumer [topic partition] options)</code></div><div class="doc"><pre class="plaintext">Requests the last committed offset for a [topic partition] (nil if nothing has been committed).

May block if the partition is not assigned to this consumer or if the consumer hasn't yet initialized its cache of committed
offsets.

A map of options may be given :

   :dvlopt.kafka/timeout
   Cf. `dvlopt.kafka` for description of time intervals</pre></div></div><div class="public anchor" id="var-consumer"><h3>consumer</h3><div class="usage"><code>(consumer)</code><code>(consumer options)</code></div><div class="doc"><pre class="plaintext">Builds a Kafka consumer.

&lt;!&gt; Consumers are NOT thread safe !
    1 consumer / thread or a queueing policy must be implemented.

A map of options may be given :

  ::configuration
    Map of Kafka consumer properties.
    Cf. <a href="https://kafka.apache.org/documentation/#newconsumerconfigs">https://kafka.apache.org/documentation/#newconsumerconfigs</a>

  :dvlopt.kafka/nodes
    List of [host port].

  :dvlopt.kafka/deserializer.key
    Prepared deserialize or a function coercing a byte-array to a key (cf. `deserializer`).

  :dvlopt.kafka/deserializer.value
    Idem, but for values.


Ex. (consumer {::configuration                  {"group.id"           "m-_group"
                                                 "enable.auto.commit" false}
               :dvlopt.kafka/nodes              [["some_host"] 9092]
               :dvlopt.kafka/deserializer.key   :string
               :dvlopt.kafka/deserializer.value (fn [data _metadata]
                                                  (some-&gt; data
                                                          nippy/thaw))})</pre></div></div><div class="public anchor" id="var-end-offsets"><h3>end-offsets</h3><div class="usage"><code>(end-offsets consumer topic-partitions)</code><code>(end-offsets consumer topic-partitions options)</code></div><div class="doc"><pre class="plaintext">Requests a map of [topic partition] -&gt; end offset (ie. offset of the last message + 1).

Works like `beginning-offsets`.</pre></div></div><div class="public anchor" id="var-fast-forward"><h3>fast-forward</h3><div class="usage"><code>(fast-forward consumer)</code><code>(fast-forward consumer topic-partitions)</code></div><div class="doc"><pre class="plaintext">Fast forwards a consumer to the end of the given [topic partition]'s.

Actually happens lazily on the next call to `poll` or `next-offset`.

If no [topic partition] is supplied, applies to all currently assigned partitions.

If the consumer was configured with :isolation.level = "read_committed", the latest offsets will be
the "last stable" ones.


Ex. ;; fast-forward all currently registered [topic partition]'s

    (fast-forward consumer)

    ;; fast-forward specific currently registered [topic partition]'s

    (fast-forward consumer
                  [["my-topic"      0]
                   ["another-topic" 3]])</pre></div></div><div class="public anchor" id="var-metrics"><h3>metrics</h3><div class="usage"><code>(metrics consumer)</code></div><div class="doc"><pre class="plaintext">Requests metrics about this consumer, exactly like `dvlopt.kafka.out/metrics`.
</pre></div></div><div class="public anchor" id="var-next-offset"><h3>next-offset</h3><div class="usage"><code>(next-offset consumer [topic partition :as topic-partition])</code><code>(next-offset consumer [topic partition] options)</code></div><div class="doc"><pre class="plaintext">Given a [topic partition], requests the offset of the next record this consumer can consume.

Issues a remote call only if there is no current position for the requested [topic partition].


A map of options may be given :

   :dvlopt.kafka/timeout
   Cf. `dvlopt.kafka` for description of time intervals


Ex. (next-offset consumer
                 ["my-topic" 0]
                 {:dvlopt.kafka/timeout [5 :seconds]})</pre></div></div><div class="public anchor" id="var-offsets-for-timestamps"><h3>offsets-for-timestamps</h3><div class="usage"><code>(offsets-for-timestamps consumer topic-partition-&gt;timestamp)</code><code>(offsets-for-timestamps consumer topic-partition-&gt;timestamp options)</code></div><div class="doc"><pre class="plaintext">Requests a map of [topic partition] -&gt; map containing :

  :dvlopt.kafka/offset 
   Earliest offset whose timestamp is greather than or equal to the given one for that [topic partition].

  :dvlopt.kafka/timestamp
   Timestamp of the record at that offset.


&lt;!&gt; Blocks forever if the topic doesn't exist and dynamic creation has been disabled server-side.


A map of options may be given :

   :dvlopt.kafka/timeout
   Cf. `dvlopt.kafka` for description of time intervals


Ex. (offsets-for-timestamps consumer
                            {["my-topic"      0] 1507812268270
                             ["another-topic" 3] 1507812338294}
                            {:dvlopt.kafka/timeout [5 :seconds]})</pre></div></div><div class="public anchor" id="var-partitions"><h3>partitions</h3><div class="usage"><code>(partitions consumer topic)</code><code>(partitions consumer topic options)</code></div><div class="doc"><pre class="plaintext">Requests a list of partitions for a given topic.

For the returned value, cf. `dvlopt.kafka.out/partitions`.

A map of options may be given :

   :dvlopt.kafka/timeout
   Cf. `dvlopt.kafka` for description of time intervals</pre></div></div><div class="public anchor" id="var-pause"><h3>pause</h3><div class="usage"><code>(pause consumer topic-partitions)</code></div><div class="doc"><pre class="plaintext">Suspends fetching records from the given [topic partition]'s until `resume` is called.

This function does not affect subscriptions nor does it trigger a consumer group rebalance.


Ex. (pause consumer
           [["my-topic"      0]
            ["another-topic" 3]])</pre></div></div><div class="public anchor" id="var-paused"><h3>paused</h3><div class="usage"><code>(paused consumer)</code></div><div class="doc"><pre class="plaintext">Returns a set of the currently paused [topic partition]'s.
</pre></div></div><div class="public anchor" id="var-poll"><h3>poll</h3><div class="usage"><code>(poll consumer)</code><code>(poll consumer options)</code></div><div class="doc"><pre class="plaintext">Synchronously polls records from the registered sources.


A map of options may be given :

   :dvlopt.kafka/timeout
   An emtpy interval such as [0 :milliseconds] returns what is available in the consumer buffer without blocking.
   Cf. `dvlopt.kafka` for description of time intervals


A record is a map containing :
 
  :dvlopt.kafka/key
   Deserialized key.

  :dvlopt.kafka/offset
   Record offset.

  :dvlopt.kafka/partition
   Partition number.

  :dvlopt.kafka/timestamp
   Unix timestamp.

  :dvlopt.kafka/topic
   Topic name.

  :dvlopt.kafka/value
   Deserialized value.</pre></div></div><div class="public anchor" id="var-poll-seq"><h3>poll-seq</h3><div class="usage"><code>(poll-seq consumer)</code><code>(poll-seq consumer options)</code></div><div class="doc"><pre class="plaintext">Returns a sequence of records obtained by lazily and continuously calling `poll` under the hood.


Ex. (take 5
          (poll-seq consumer
                    {:dvlopt.kafka/timeout [5 :seconds]}))</pre></div></div><div class="public anchor" id="var-poll-topic-partitions"><h3>poll-topic-partitions</h3><div class="usage"><code>(poll-topic-partitions consumer)</code><code>(poll-topic-partitions consumer options)</code></div><div class="doc"><pre class="plaintext">Behaves exactly like `poll` but returns a map of [topic partition] -&gt; list of record.

More efficient when records are dispatched to workers by [topic partition].</pre></div></div><div class="public anchor" id="var-register-for"><h3>register-for</h3><div class="usage"><code>(register-for consumer source)</code><code>(register-for consumer source options)</code></div><div class="doc"><pre class="plaintext">A consumer can either be assigned to a list of specific [topic partition]'s by the user or subscribe
to a list of topics or a regular expression describing topics. When subscribing, the [topic partition]'s
are dynamically assigned by the broker. Assignments change over time. For instance, when another consumer
from the same consumer group subscribes to the same topics, [topic partition]'s are rebalanced between
consumers so that one of them does not overwork or underwork.

Everytime this function is called, the consumer is unregistered from previous sources if there are any.

A map of options may be given :

  ::on-rebalance
   Callback in order to be informed in case of dynamic :assignment or :revocation (first argument) regarding
   [topic partition]'s (second argument).


Ex. ;; dynamic subscription by regular expression

    (register-for consumer
                  #"topic-.+"
                  {::on-rebalance (fn [operation topic-partitions]
                                    (when (= operation
                                             :assignment)
                                      ...))})

    ;; dynamic subscription to given topics

    (register-for consumer
                  ["my-topic"
                   "another-topic"])

    ;; static assignment to specific [topic partition]'s

    (register-for consumer
                  [["my-topic"      0]
                   ["another-topic" 3]])</pre></div></div><div class="public anchor" id="var-registered-for"><h3>registered-for</h3><div class="usage"><code>(registered-for consumer)</code></div><div class="doc"><pre class="plaintext">Returns a map containing :

::assignments
 Set of all [topic partition]'s the consumer is currently assigned to, either by the broker or by the user.

::subscriptions
 Set of all topics the consumer is subscribed to, if any.</pre></div></div><div class="public anchor" id="var-registered-for.3F"><h3>registered-for?</h3><div class="usage"><code>(registered-for? consumer source)</code></div><div class="doc"><pre class="plaintext">Is the consumer listening to the given topic / [topic partition] ?
</pre></div></div><div class="public anchor" id="var-resume"><h3>resume</h3><div class="usage"><code>(resume consumer)</code><code>(resume consumer topic-partitions)</code></div><div class="doc"><pre class="plaintext">Undoes `pause`.


Ex. ;; resumes everything that has been paused

    (resume consumer)

    ;; resumes only specific [topic partition]'s
 
    (resume [["my-topic"      0]
             ["another-topic" 3]])</pre></div></div><div class="public anchor" id="var-rewind"><h3>rewind</h3><div class="usage"><code>(rewind consumer)</code><code>(rewind consumer topic-partitions)</code></div><div class="doc"><pre class="plaintext">Rewinds a consumer to the first available offset for the given [topic partition]'s.

Actually happens lazily on the next call to `poll` or `next-offset`.


Ex. ;; rewind all currently registered [topic partition]'s
    
    (rewind consumer)

    ;; rewind only specific currently registered [topic partition]'s

    (rewind consumer
            [["my-topic"      0]
             ["another-topic" 3]])</pre></div></div><div class="public anchor" id="var-seek"><h3>seek</h3><div class="usage"><code>(seek consumer topic-partition-&gt;offset)</code></div><div class="doc"><pre class="plaintext">Moves the consumer to the new offsets.

Actually happens lazily on the next call to `poll` and variations.


Ex. (seek consumer
          {["my-topic"      0] 42
           ["another-topic" 3] 84})</pre></div></div><div class="public anchor" id="var-topics"><h3>topics</h3><div class="usage"><code>(topics consumer)</code><code>(topics consumer options)</code></div><div class="doc"><pre class="plaintext">Requests a list of metadata about partitions for all topics the consumer is authorized to consume.

Returns a map of topic -&gt; list of metadata exactly like in `partitions`.

A map of options may be given :

   :dvlopt.kafka/timeout
   Cf. `dvlopt.kafka` for description of time intervals</pre></div></div><div class="public anchor" id="var-unregister"><h3>unregister</h3><div class="usage"><code>(unregister consumer)</code></div><div class="doc"><pre class="plaintext">Unregisters a consumer from all the sources it is consuming.
</pre></div></div></div></body></html>