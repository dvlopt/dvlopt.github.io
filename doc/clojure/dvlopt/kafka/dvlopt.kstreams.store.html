<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>dvlopt.kstreams.store documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Kafka</span> <span class="project-version">1.0.0-beta1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dvlopt</span></div></div></li><li class="depth-2"><a href="dvlopt.kafka.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kafka</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kafka.admin.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>admin</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kafka.in.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>in</span></div></a></li><li class="depth-3"><a href="dvlopt.kafka.out.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>out</span></div></a></li><li class="depth-2"><a href="dvlopt.kstreams.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>kstreams</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kstreams.builder.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>builder</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kstreams.ctx.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ctx</span></div></a></li><li class="depth-3 branch current"><a href="dvlopt.kstreams.store.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>store</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kstreams.stream.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stream</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kstreams.table.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>table</span></div></a></li><li class="depth-3"><a href="dvlopt.kstreams.topology.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>topology</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-close-cursor"><div class="inner"><span>close-cursor</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-flush"><div class="inner"><span>flush</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-kv-count"><div class="inner"><span>kv-count</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-kv-get"><div class="inner"><span>kv-get</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-kv-offer"><div class="inner"><span>kv-offer</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-kv-put"><div class="inner"><span>kv-put</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-kv-range"><div class="inner"><span>kv-range</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-kv-remove"><div class="inner"><span>kv-remove</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-open.3F"><div class="inner"><span>open?</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-persistent.3F"><div class="inner"><span>persistent?</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-ss-multi-get"><div class="inner"><span>ss-multi-get</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-ss-multi-range"><div class="inner"><span>ss-multi-range</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-store-name"><div class="inner"><span>store-name</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-ws-get"><div class="inner"><span>ws-get</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-ws-multi-get"><div class="inner"><span>ws-multi-get</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-ws-multi-range"><div class="inner"><span>ws-multi-range</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.store.html#var-ws-put"><div class="inner"><span>ws-put</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">dvlopt.kstreams.store</h1><div class="doc"><pre class="plaintext">Kafka Streams state stores.


Streaming applications often need to store some kind of state. This is the purposes of state stores which are typically backed-up
to compacted Kafka topics called changelogs in order to be fault-tolerant. Those changelogs topics are named '$APPLICATION_ID-$GENERATED_NAME-changelog`.

Stores
======

Three type of stores exist, typically persistent by using RocksDB under the hood :


  Key-value stores
  ----------------

  Behave like regular tables or, when decided, like LRU ones. A regular key-value store can also be in-memory rather than persistent,
  which is great for cloud environments where applications are started from scratch everytime. However, an in-memory key-value
  store will have to catch up with its corresponding changelog everytime the application is restarted.

  Persistent window stores
  -----------------------------

  In window stores, each value is associated with a key but also a timestamp. They are used for computing over fixed time intervals.

  Persistent session stores
  -------------------------

  Sessions are non-fixed intervals of activity organized around fixed intervals of inactivity.
 
  For the same key, with an interval of 5 seconds, let us suppose we receive values at time 10, 12 and 20. There is a gap of more than
  5 seconds between event 2 and 3. Hence, event 3 would be part of another session. Now let us suppose a 4th event arrives out of order
  with a timestamp of 16. Now, all 4 events would merge into the same session as no event is more than 5 seconds away from another one.


In the high-level API, stores are often created automatically but can be tweaked to some extent. When a store needs to be created manually,
these options might be provided :

 :dvlopt.kafka/deserializer.key
 :dvlopt.kafka/deserializer.value
 :dvlopt.kafka/serializer.key
 :dvlopt.kafka/serializer.value
  Cf. `dvlopt.kafka` for description of serializers and deserializers.

 ::cache?
  Caching tries to minimize the number of updates. For instance, if 2 subsequent values share the same key, only the second one
  will be persisted. It improves performance and IO but it means records will not be persisted as soon as possible.
  True by default, should be false only for testing and debugging.

 ::changelog?
  In order for state stores to be fault tolerant, they are continuously backed up to a changelog topic behind the scenes.
  Default is true and this option should not be disabled unless specifically needed.

 ::configuration.changelog
  Map of Kafka topic properties for configuring the changelog topic.
  Cf. <a href="https://kafka.apache.org/documentation/#topicconfigs">https://kafka.apache.org/documentation/#topicconfigs</a>

 ::name
  Generated in the form of 'dvlopt.kafka-store-8_DIGIT_NUMBER' when not supplied.

 ::type
  Determines the type of the store, one of :

    :kv.in-memory
    :kv.lru
    :kv.regular
    :session
    :window

 LRU key-value stores have this additional option :

    ::lru-size
      Maximum number of items in the LRU store.

 Session and window stores have these additional options :

   ::retention 
    Time period for which the state store will retain historical data, cannot be smaller than the chosen interval.
    During any kind of stream processing, it is common that data arrives late or out of order and instead of dropping this data,
    it is better to update past time windows. However, because disks are not unlimited, one cannot keep the data for all time windows
    just in case. Hence the need for this option. The higher the retention period and the later can data arrive, but the more is stored.
    Default is [1 :days].

 Window stores have these additional options and mandatory arguments :

   ::duplicate-keys?
    Whether or not to retain duplicate keys, akin to caching.
    Default is false.

   ::interval (mandatory)
    Fixed interval of each window.
    Cf. `dvlopt.kafka` for description of time intervals

   ::segments
    Number of database segments (must be &gt;= 2).
    Default is 2.


Cursors
=======

Retrieving several values from a store always returns a stateful iterator implementing Closeable and acting as a database cursor. It must be
closed after usage otherwise resources will leak. For ease of use, the iterator can be transformed into a sequence by using clojure's `iterator-seq`.
However, the resulting sequence should be consumed eagerly right away.

Each item is a map containing :

  :dvlopt.kafka/key
   Deserialized key.

  :dvlopt.kafka/value
   Deserialized value.

Window stores and sessions stores items also have :

  :dvlopt.kafka/timestamp.from
   Window beginning.

  :dvlopt.kafka/timestamp.to
   Window end.


Ex. ;; Eargerly sum all values.
 
    (with-open [kvs (dvlopt.kstreams.store/kv-range my-store)]
      (reduce (fn [sum kv]
                (+ sum
                   (:dvlopt.kafka/value kv)))
              0
              (iterator-seq kvs)))</pre></div><div class="public anchor" id="var-close-cursor"><h3>close-cursor</h3><div class="usage"><code>(close-cursor cursor)</code></div><div class="doc"><pre class="plaintext">Closes a cursor.
</pre></div></div><div class="public anchor" id="var-flush"><h3>flush</h3><div class="usage"><code>(flush store)</code></div><div class="doc"><pre class="plaintext">Flushes any cached data.
</pre></div></div><div class="public anchor" id="var-kv-count"><h3>kv-count</h3><div class="usage"><code>(kv-count kv-store)</code></div><div class="doc"><pre class="plaintext">Returns the approximate number of entries in the key-value store.
</pre></div></div><div class="public anchor" id="var-kv-get"><h3>kv-get</h3><div class="usage"><code>(kv-get kv-store k)</code></div><div class="doc"><pre class="plaintext">Returns the value mapped to the given key in the key-value store.
</pre></div></div><div class="public anchor" id="var-kv-offer"><h3>kv-offer</h3><div class="usage"><code>(kv-offer kv-store k v)</code></div><div class="doc"><pre class="plaintext">Adds the key-value to the key-value store only if the key does not exist yet.

Returns the already existing value or nil.</pre></div></div><div class="public anchor" id="var-kv-put"><h3>kv-put</h3><div class="usage"><code>(kv-put kv-store kvs)</code><code>(kv-put kv-store k v)</code></div><div class="doc"><pre class="plaintext">Adds the key-value to the key-value store.

A list of [key value]'s can be provided.</pre></div></div><div class="public anchor" id="var-kv-range"><h3>kv-range</h3><div class="usage"><code>(kv-range kv-store)</code><code>(kv-range kv-store from-key to-key)</code></div><div class="doc"><pre class="plaintext">Returns a cursor for a range of keys or all of them if no range is specified.

Cf. Namespace description for a description of cursors.</pre></div></div><div class="public anchor" id="var-kv-remove"><h3>kv-remove</h3><div class="usage"><code>(kv-remove store k)</code></div><div class="doc"><pre class="plaintext">Removes the key from the key-value store.

Returns the existing value for that key or nil.</pre></div></div><div class="public anchor" id="var-open.3F"><h3>open?</h3><div class="usage"><code>(open? store)</code></div><div class="doc"><pre class="plaintext">Is this store open for IO ?
</pre></div></div><div class="public anchor" id="var-persistent.3F"><h3>persistent?</h3><div class="usage"><code>(persistent? store)</code></div><div class="doc"><pre class="plaintext">Is this store persistent ? Rather than in-memory ?
</pre></div></div><div class="public anchor" id="var-ss-multi-get"><h3>ss-multi-get</h3><div class="usage"><code>(ss-multi-get session-store k)</code><code>(ss-multi-get session-store k options)</code></div><div class="doc"><pre class="plaintext">Like `ws-multi-get` but for session stores.

For internal reasons, only writable session stores can work with options.</pre></div></div><div class="public anchor" id="var-ss-multi-range"><h3>ss-multi-range</h3><div class="usage"><code>(ss-multi-range session-store from-key to-key)</code><code>(ss-multi-range session-store from-key to-key options)</code></div><div class="doc"><pre class="plaintext">Like `ws-multi-range` but for session stores and the range must always be specified.

For internal reasons, only writable session stores can work with options.</pre></div></div><div class="public anchor" id="var-store-name"><h3>store-name</h3><div class="usage"><code>(store-name store)</code></div><div class="doc"><pre class="plaintext">Returns the name of the given store which might be automatically generated.
</pre></div></div><div class="public anchor" id="var-ws-get"><h3>ws-get</h3><div class="usage"><code>(ws-get window-store k timestamp)</code></div><div class="doc"><pre class="plaintext">Returns the value mapped to the given key at the given timestamp in the window store.
</pre></div></div><div class="public anchor" id="var-ws-multi-get"><h3>ws-multi-get</h3><div class="usage"><code>(ws-multi-get window-store k)</code><code>(ws-multi-get window-store k options)</code></div><div class="doc"><pre class="plaintext">Returns a cursor for several windows for the given key in the window store.


A map of options may be given :

  :dvlopt.kafka/timestamp.from
    Earliest timestamp, defaults to 0.
    
  :dvlopt.kafka/timestamp.to
    Latest timestamp, defaults to current system time.


Cf. Namespace description for a description of cursors.</pre></div></div><div class="public anchor" id="var-ws-multi-range"><h3>ws-multi-range</h3><div class="usage"><code>(ws-multi-range window-store)</code><code>(ws-multi-range window-store options)</code><code>(ws-multi-range window-store from-key to-key)</code><code>(ws-multi-range window-store from-key to-key options)</code></div><div class="doc"><pre class="plaintext">Like `ws-multi-get` but for a range of keys (or all of them if no range is provided.
</pre></div></div><div class="public anchor" id="var-ws-put"><h3>ws-put</h3><div class="usage"><code>(ws-put window-store k v)</code><code>(ws-put window-store k v timestamp)</code></div><div class="doc"><pre class="plaintext">Adds a key to the window store.

If none is provided, the timestamp will be the system time.</pre></div></div></div></body></html>