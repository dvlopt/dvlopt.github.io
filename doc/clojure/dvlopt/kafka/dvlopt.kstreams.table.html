<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>dvlopt.kstreams.table documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Kafka</span> <span class="project-version">1.2.0-beta0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dvlopt</span></div></div></li><li class="depth-2"><a href="dvlopt.kafka.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kafka</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kafka.admin.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>admin</span></div></a></li><li class="depth-3"><a href="dvlopt.kafka.in.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>in</span></div></a></li><li class="depth-4"><a href="dvlopt.kafka.in.mock.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mock</span></div></a></li><li class="depth-3"><a href="dvlopt.kafka.out.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>out</span></div></a></li><li class="depth-4"><a href="dvlopt.kafka.out.mock.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mock</span></div></a></li><li class="depth-2"><a href="dvlopt.kstreams.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>kstreams</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kstreams.builder.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>builder</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kstreams.ctx.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ctx</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kstreams.store.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>store</span></div></a></li><li class="depth-3 branch"><a href="dvlopt.kstreams.stream.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stream</span></div></a></li><li class="depth-3 branch current"><a href="dvlopt.kstreams.table.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>table</span></div></a></li><li class="depth-3"><a href="dvlopt.kstreams.topology.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>topology</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="dvlopt.kstreams.table.html#var-filter-kv"><div class="inner"><span>filter-kv</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.table.html#var-join-with-table"><div class="inner"><span>join-with-table</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.table.html#var-left-join-with-table"><div class="inner"><span>left-join-with-table</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.table.html#var-map-and-group-by"><div class="inner"><span>map-and-group-by</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.table.html#var-map-values"><div class="inner"><span>map-values</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.table.html#var-outer-join-with-table"><div class="inner"><span>outer-join-with-table</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.table.html#var-process-values"><div class="inner"><span>process-values</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.table.html#var-reduce-values"><div class="inner"><span>reduce-values</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.table.html#var-store-name"><div class="inner"><span>store-name</span></div></a></li><li class="depth-1"><a href="dvlopt.kstreams.table.html#var-to-stream"><div class="inner"><span>to-stream</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">dvlopt.kstreams.table</h1><div class="doc"><pre class="plaintext">Kafka Streams' abstraction of tables.

Cf. `dvlopt.kstreams.builder` for the big picture and details


A table can be transformed by various functions. Those functions always return a new table representing the transformation.
Hence, a single table can be used for more than one transformation.

A table can be re-grouped by other keys using the `map-and-group-by` function and then the values aggregated for each key,
resulting in a new table.

A table can also be joined with another table.


A table is backed-up by a state store. As such, these options, called the standard options in this namespace, can very often
be supplied :

  :dvlopt.kafka/deserializer.key
  :dvlopt.kafka/deserializer.value
  :dvlopt.kafka/serializer.key
  :dvlopt.kafka/serializer.value
   Cf. `dvlopt.kafka` for description of serializers and deserializers

  :dvlopt.kstreams.store/cache?
  :dvlopt.kstreams.store/changelog?
  :dvlopt.kstreams.store/configuration.changelog
  :dvlopt.kstreams.store/name
  :dvlopt.kstreams.store/type
   Exactly as described in `dvlopt.kstreams.store` but the type is restricted to #{:kv.in-memory :kv.regular}.</pre></div><div class="public anchor" id="var-filter-kv"><h3>filter-kv</h3><div class="usage"><code>(filter-kv table predicate)</code><code>(filter-kv table predicate standard-options)</code></div><div class="doc"><pre class="plaintext">Returns a table filtering out key-values returning false on the given predicate.

Keys with nil values are removed right away.


Standard options can be provided (cf. namespace description).


Ex. (filter-kv table
               (fn [k v]
                 (&gt;= (:age v)
                     18)))</pre></div></div><div class="public anchor" id="var-join-with-table"><h3>join-with-table</h3><div class="usage"><code>(join-with-table left-table right-table f)</code><code>(join-with-table left-table right-table f standard-options)</code></div><div class="doc"><pre class="plaintext">Returns a table joining values from both tables when they share the same key.

Records with nil values removes the corresponding key from the resulting table. Records with nil keys will be dropped.

Cf. `dvlopt.kstreams.builder` for requirements related to joins


Standard options can be provided (cf. namespace description).


Ex. (join-with-table left-table
                     right-table
                     (fn [v-left v-right]
                       (merge v-left
                              v-right)))</pre></div></div><div class="public anchor" id="var-left-join-with-table"><h3>left-join-with-table</h3><div class="usage"><code>(left-join-with-table left-table right-table f)</code><code>(left-join-with-table left-table right-table f options)</code></div><div class="doc"><pre class="plaintext">Exactly like `join-with-table` but the join is triggered even if the right table does not contain the key yet.
In such case, the right value provided for the join is nil.</pre></div></div><div class="public anchor" id="var-map-and-group-by"><h3>map-and-group-by</h3><div class="usage"><code>(map-and-group-by table f)</code><code>(map-and-group-by table f options)</code></div><div class="doc"><pre class="plaintext">Returns a grouped table mapping key-values and then re-grouping them based on the new keys.

Drops mapped records with nil keys.

Because a new key is explicitly selected, the data is repartioned.
Cf. `dvlopt.kstreams.builder` about repartioning.

A map of options may be given :

  :dvlopt.kafka/deserializer.key
  :dvlopt.kafka/deserializer.value
  :dvlopt.kafka/serializer.key
  :dvlopt.kafka/serializer.value
   Cf. `dvlopt.kafka` for description of serializers and deserializers

  :dvlopt.kstreams/repartition-name
   Cf. `dvlopt.kstreams.builder` section "State and repartitioning"


Ex. ;; Re-groups a table on countries while remembering from which user are the values.

    (map-and-group-by table
                      (fn [k v]
                        [(:country v)
                         (assoc v
                                :user-id
                                k)]))</pre></div></div><div class="public anchor" id="var-map-values"><h3>map-values</h3><div class="usage"><code>(map-values table f)</code><code>(map-values table f standard-options)</code></div><div class="doc"><pre class="plaintext">Returns a table mapping the value of each key-value.


Standard options can be provided (cf. namespace description).


Ex. (map-values table
                (fn [k v]
                  (assoc v
                         :country
                         (country-from-ip (:ip v)))))</pre></div></div><div class="public anchor" id="var-outer-join-with-table"><h3>outer-join-with-table</h3><div class="usage"><code>(outer-join-with-table left-table right-table f)</code><code>(outer-join-with-table left-table right-table f options)</code></div><div class="doc"><pre class="plaintext">Exactly like `join-outer-with-table` but the join is triggered even if the other table does not contain the key yet.
In such case, the value provided for this side of the join is nil.</pre></div></div><div class="public anchor" id="var-process-values"><h3>process-values</h3><div class="usage"><code>(process-values table processor)</code><code>(process-values table processor options)</code></div><div class="doc"><pre class="plaintext">Just like ´dvlopt.kstreams.stream/process-value` but with a table.


Standard options can be provided (cf. namespace description).</pre></div></div><div class="public anchor" id="var-reduce-values"><h3>reduce-values</h3><div class="usage"><code>(reduce-values grouped-table fn-reduce-add fn-reduce-sub fn-seed)</code><code>(reduce-values grouped-table f-add f-sub seed options)</code></div><div class="doc"><pre class="plaintext">Returns a new table aggregating the values for each key of the given grouped table.

Let us take the example provided in `map-and-group-by` where users were re-grouped by country. Let us say each user has an :income and
we want to sum all incomes for each country.

A seed (sum of incomes) is created for each grouped key (country). Each new value (a user with an income) is aggregated using (reduce-add [agg k v])
in order to increase the country sum. If the user is removed, then its income is removed from the country sum using (reduce-sub [agg k v]). If the
value for an existing user is replaced, then both functions are called in undefined order for updating the country sum with the possibly new income.


Ex. (reduce-values grouped-table
                   (fn reduce-add [country-income country user]
                     (+ country-income
                        (:income user)))
                   (fn reduce-sub [country-income country user]
                     (- country-income
                        (:income user)))
                   (fn seed []
                     0))</pre></div></div><div class="public anchor" id="var-store-name"><h3>store-name</h3><div class="usage"><code>(store-name table)</code></div><div class="doc"><pre class="plaintext">Returns the name of the local underlying state store that can be used to query this table, or nil if the table cannot be
queried.</pre></div></div><div class="public anchor" id="var-to-stream"><h3>to-stream</h3><div class="usage"><code>(to-stream table)</code><code>(to-stream table f)</code></div><div class="doc"><pre class="plaintext">Turns a table into a stream.

A function can be provided for selecting new keys.


Ex. ;; The new key is the length of the value.

    (to-stream table
               (fn [k v]
                 (count v)))</pre></div></div></div></body></html>