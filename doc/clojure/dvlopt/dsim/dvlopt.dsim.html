<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>dvlopt.dsim documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Dsim</span> <span class="project-version">0.0.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="dvlopt.dsim.html"><div class="inner"><span>dvlopt.dsim</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="dvlopt.dsim.html#var-deep-merge"><div class="inner"><span>deep-merge</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-dissoc-in"><div class="inner"><span>dissoc-in</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-fn-assoc-data"><div class="inner"><span>fn-assoc-data</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-fn-infinite"><div class="inner"><span>fn-infinite</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-fn-mirror"><div class="inner"><span>fn-mirror</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-fn-mirror-percent"><div class="inner"><span>fn-mirror-percent</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-fn-once"><div class="inner"><span>fn-once</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-fn-poly"><div class="inner"><span>fn-poly</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-fn-poly-infinite"><div class="inner"><span>fn-poly-infinite</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-fn-poly-repeating"><div class="inner"><span>fn-poly-repeating</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-fn-repeating"><div class="inner"><span>fn-repeating</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-fn-scale"><div class="inner"><span>fn-scale</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-in-transition.3F"><div class="inner"><span>in-transition?</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-infinite"><div class="inner"><span>infinite</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-last-step"><div class="inner"><span>last-step</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-merge-transitions"><div class="inner"><span>merge-transitions</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-millis-.3En-steps"><div class="inner"><span>millis-&gt;n-steps</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-move"><div class="inner"><span>move</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-move-events"><div class="inner"><span>move-events</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-move-seq"><div class="inner"><span>move-seq</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-once"><div class="inner"><span>once</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-pipe-complete"><div class="inner"><span>pipe-complete</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-poly"><div class="inner"><span>poly</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-poly-infinite"><div class="inner"><span>poly-infinite</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-poly-repeating"><div class="inner"><span>poly-repeating</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-remove-data"><div class="inner"><span>remove-data</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-remove-pre-data"><div class="inner"><span>remove-pre-data</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-remove-transition"><div class="inner"><span>remove-transition</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-repeating"><div class="inner"><span>repeating</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-scale"><div class="inner"><span>scale</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-step-key"><div class="inner"><span>step-key</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-transition-key"><div class="inner"><span>transition-key</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-transition-path"><div class="inner"><span>transition-path</span></div></a></li><li class="depth-1"><a href="dvlopt.dsim.html#var-without-transitions"><div class="inner"><span>without-transitions</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">dvlopt.dsim</h1><div class="doc"><pre class="plaintext">Idiomatic, purely-functional discrete event simulation.


A transition is pure stepwise function gradually modifying some arbitrary state map. Transitions are part of the state itself
and are located under the `transition-key` key. They can be organized in arbitrarily nested maps. It is both common and desired
for transitions to mirror the data they act upon :


  {dvlopt.dsim/transition-key {:asteroids {42 {:x ...
                                               :y ...}}}
   :asteroids {42 {:x 450
                   :y 1420}}}

This pattern is so common that in this example, [:asteroids 42 :x] would be called the `data-path` of the :x transition of
asteroid 42. Such a transition accepts 3 arguments: a state map, its data-path, and a step. It returns a new state which, although
not enforced, should somehow modify the :x value of asteroid 42.

For doing so, a transition is created by providing an `on-step` function which also accepts 3 arguments: a state map, the data-path,
and a percentage of completion. This percentage depends on the first step of the transition, how many steps it lasts, and the
current step:  (current-step - first-step) / n-steps.

After reaching 100%, if it was provided in the first place, the `on-complete` function of the transition is called. It accepts
4 arguments: the current state map, the data-path, the completion step, and the current step. It is useful when action must be
taken after a transition, for instance for creating a new one. If some steps are missed or skipped, the completion step and the
current step will not match. Hence it is useful to provide both. Completed transitions are removed automatically.

  Cf. `infinite`
      `once`
      `repeating`

A poly-transition is a higher-order transition composed of several transitions. At the end of each sub-transition, the poly-transition
takes care of creating the next one at the right moment. Hence, it would be easy to animate asteroid 42 to sequentially move in
different directions, or to sequentially rotate in some complex manner. It is also trivial to create nested poly-transitions.

  Cf. `poly`
      `poly-infinite`
      `poly-repeating`


Scaling a percentage to a value such as the :x position of an asteroid is facilitated by using `scale` and `fn-scale`. It is often
needed for a transition to behave non-linearly. This can be simply done by modifying the percentage of completion, which is a linear
progression, to be non-linear. For example, if an asteroid has to move faster and faster along the :x axis from 500 to 1000 pixels in a
100 steps starting from step 0:

  (dvlopt.dsim/once 0
                    100
                    (let [scale' (dvlopt.dsim/fn-scale 500
                                                       1000)]
                      (fn on-step [state data-path percent]
                        (assoc-in state
                                  data-path
                                  (scale' (Math/pow percent
                                                    2))))))

The most straightforward way to add or remove transitions to a state is by using `merge-transitions`. A series of helpers for `on-step`
and `on-complete` functions is provided. For example, improving the last example and removing the asteroid when done :

  (dvlopt.dsim/once 0
                    100
                    (dsim/fn-mirror-percent (comp (dvlopt.dsim/fn-scale 500
                                                                        1000)
                                                  #(Math/pow %
                                                             2)))
                    dsim/remove-pre-data)


The most basic way of moving a state to some step is done by using `move`. `move-seq` facilitates the process of iteratively moving
through a sequence of steps. However, the most useful way is probably `move-events` which also takes into account events happening at
some particular steps, each modifying the state is some way. Any non-trivial simulation involves such events.</pre></div><div class="public anchor" id="var-deep-merge"><h3>deep-merge</h3><div class="usage"><code>(deep-merge hmap-1 hmap-2)</code></div><div class="doc"><pre class="plaintext">Deep merges two maps.
</pre></div></div><div class="public anchor" id="var-dissoc-in"><h3>dissoc-in</h3><div class="usage"><code>(dissoc-in hmap [k &amp; ks :as path])</code></div><div class="doc"><pre class="plaintext">Deep dissoc, natural counterpart of Clojure's `assoc-in`.

Empty maps are removed.


Ex. (dissoc-in {:a {:b 42}
                :c :ok}
               [:a :b])

    =&gt; {:c :ok}</pre></div></div><div class="public anchor" id="var-fn-assoc-data"><h3>fn-assoc-data</h3><div class="usage"><code>(fn-assoc-data data)</code></div><div class="doc"><pre class="plaintext">Returns a function assoc'ing the given data at the data-path of a transition.

Useful when some steps might be skipped but it is needed for a transition to reach 100%. For instance,
during a live animation, a frame will probably not be drawn at the exact millisecond a transition should
complete but some milliseconds later. The returned function can be used as an `on-complete` function
so that the state will always reflect the last step of such a transition.</pre></div></div><div class="public anchor" id="var-fn-infinite"><h3>fn-infinite</h3><div class="usage"><code>(fn-infinite n-steps on-step)</code></div><div class="doc"><pre class="plaintext">Returns a function returning an infinite transition.

Useful for poly-transitions.


Cf. `infinite`
    `poly`</pre></div></div><div class="public anchor" id="var-fn-mirror"><h3>fn-mirror</h3><div class="usage"><code>(fn-mirror map-percent)</code></div><div class="doc"><pre class="plaintext">Given an `on-step` function returning some arbitrary value instead of a new state, returns an `on-step`
function assoc'ing this value at the data-path in the state.

Idiomatic.</pre></div></div><div class="public anchor" id="var-fn-mirror-percent"><h3>fn-mirror-percent</h3><div class="usage"><code>(fn-mirror-percent map-only-percent)</code></div><div class="doc"><pre class="plaintext">Behaves just like `fn-mirror` but the function provided in the first place simply maps a percent value to
an arbitrary one instead of being an `on-step` function.

Small convenient helper when the current state and data-path are not needed.</pre></div></div><div class="public anchor" id="var-fn-once"><h3>fn-once</h3><div class="usage"><code>(fn-once n-steps on-step)</code><code>(fn-once n-steps on-step on-complete)</code></div><div class="doc"><pre class="plaintext">Returns a function returning a transition.

Useful for poly-transitions.


Cf. `once`
    `poly`</pre></div></div><div class="public anchor" id="var-fn-poly"><h3>fn-poly</h3><div class="usage"><code>(fn-poly fn-transitions)</code><code>(fn-poly fn-transitions on-complete)</code></div><div class="doc"><pre class="plaintext">Returns a function returning a poly-transition.

Useful for nested poly-transitions.


Cf. `poly`</pre></div></div><div class="public anchor" id="var-fn-poly-infinite"><h3>fn-poly-infinite</h3><div class="usage"><code>(fn-poly-infinite fn-transitions)</code></div><div class="doc"><pre class="plaintext">Returns a function returning an infinite poly-transition.

Useful for nested poly-transitions.


Cf. `poly`
    `poly-infinite`</pre></div></div><div class="public anchor" id="var-fn-poly-repeating"><h3>fn-poly-repeating</h3><div class="usage"><code>(fn-poly-repeating n-times fn-transitions)</code><code>(fn-poly-repeating n-times fn-transitions on-complete)</code></div><div class="doc"><pre class="plaintext">Returns a function returning a repeating poly-transition.

Useful for nested poly-transitions.


Cf. `poly`
    `poly-repeating`</pre></div></div><div class="public anchor" id="var-fn-repeating"><h3>fn-repeating</h3><div class="usage"><code>(fn-repeating n-times n-steps on-step)</code><code>(fn-repeating n-times n-steps on-step on-complete)</code></div><div class="doc"><pre class="plaintext">Returns a function returning a repeating transition.

Useful for poly-transitions.


Cf. `repeating`
    `poly`</pre></div></div><div class="public anchor" id="var-fn-scale"><h3>fn-scale</h3><div class="usage"><code>(fn-scale scaled-a scaled-b)</code><code>(fn-scale scaled-a scaled-b a b)</code></div><div class="doc"><pre class="plaintext">Exactly like `scale` but does not accept a value to scale. Instead, returns a function which does so.

Particularly useful when working with the percentage of completion of transitions.</pre></div></div><div class="public anchor" id="var-in-transition.3F"><h3>in-transition?</h3><div class="usage"><code>(in-transition? state)</code><code>(in-transition? state data-path)</code></div><div class="doc"><pre class="plaintext">Is the given state or some part of it currently in transition?
</pre></div></div><div class="public anchor" id="var-infinite"><h3>infinite</h3><div class="usage"><code>(infinite first-step n-steps on-step)</code></div><div class="doc"><pre class="plaintext">Returns a transition endlessly repeating cycles of `n-steps` steps.

Obviously, it does not need an `on-complete` function.</pre></div></div><div class="public anchor" id="var-last-step"><h3>last-step</h3><div class="usage"><code>(last-step first-step n-steps)</code></div><div class="doc"><pre class="plaintext">Simplify provides the last step of a transition given its first-step and the number of steps it lasts.
</pre></div></div><div class="public anchor" id="var-merge-transitions"><h3>merge-transitions</h3><div class="usage"><code>(merge-transitions state transitions)</code></div><div class="doc"><pre class="plaintext">Deep merges the provided - often nested - map of transitions in the given state.

Very useful for adding or removing several transitions at once. Indeed, nil values are simply removed when moving the state.</pre></div></div><div class="public anchor" id="var-millis-.3En-steps"><h3>millis-&gt;n-steps</h3><div class="usage"><code>(millis-&gt;n-steps millis hz)</code></div><div class="doc"><pre class="plaintext">Computes the number of steps needed for completing a transition in `millis` milliseconds for a phenomenon,
such as the frame-rate, happening `hz` per second.


Ex. Computing the number of frames needed in order to last 2000 milliseconds with a frame-rate of 60.

    (millis-&gt;n-steps 2000
                     60)

    =&gt; 120</pre></div></div><div class="public anchor" id="var-move"><h3>move</h3><div class="usage"><code>(move state step)</code></div><div class="doc"><pre class="plaintext">Moves a state to the given step (ie. returns a new state representing the given state at the given step).

It belongs to the user to ensure steps are not skipped if it is the needed behavior.</pre></div></div><div class="public anchor" id="var-move-events"><h3>move-events</h3><div class="usage"><code>(move-events state step-seq events handle-event)</code></div><div class="doc"><pre class="plaintext">Merely moving a state is often not enough. Typically, some events happen which modify the state in some way, add, remove,
or replace transitions. This function does exactly that.

It behaves like `move-seq` in that it moves an initial state following a sequence of steps. However, the state is also modified
by following a sequence of events and an event handler.

An event is an arbitrary map which describes something happening at some arbitrary step. As such, it must have a step associated
under the `step-key` key. Events are assumed to be sorted in chronological order (ie. by step).

`handle-event` takes the current state and an event, it must return a new state. It is called everytime an event happens.


Like `move-seq`, returns a lazy sequence of [state' step].</pre></div></div><div class="public anchor" id="var-move-seq"><h3>move-seq</h3><div class="usage"><code>(move-seq state step-seq)</code></div><div class="doc"><pre class="plaintext">Returns a lazy sequence of [state' step] by iteratively moving the given state following the given sequence of steps.

Stops as soon as it reaches the end of `step-seq` or it detects there no more transitions, meaning it is useless to
continue.</pre></div></div><div class="public anchor" id="var-once"><h3>once</h3><div class="usage"><code>(once first-step n-steps on-step)</code><code>(once first-step n-steps on-step on-complete)</code></div><div class="doc"><pre class="plaintext">Returns a transition lasting `n-steps` steps.
</pre></div></div><div class="public anchor" id="var-pipe-complete"><h3>pipe-complete</h3><div class="usage"><code>(pipe-complete on-completes)</code></div><div class="doc"><pre class="plaintext">Given a collection of `on-complete` functions, returns an `on-complete` function piping arguments into this collection.

Nil values are simply filtered-out.</pre></div></div><div class="public anchor" id="var-poly"><h3>poly</h3><div class="usage"><code>(poly state first-step fn-transitions)</code><code>(poly state first-step fn-transitions on-complete)</code></div><div class="doc"><pre class="plaintext">Returns a poly-transition which will follow a collection of functions producing transitions.

Those functions will be provided with the state at the moment the transition is created, the first-step 
of this transition and an `on-complete` function which must not be ignored. This `on-complete` function
ensures that the next transition, if there is one, will be created.</pre></div></div><div class="public anchor" id="var-poly-infinite"><h3>poly-infinite</h3><div class="usage"><code>(poly-infinite state first-step fn-transitions)</code></div><div class="doc"><pre class="plaintext">Union of `infinite` and `poly`. Returns a poly-transition endlessly repeating.
</pre></div></div><div class="public anchor" id="var-poly-repeating"><h3>poly-repeating</h3><div class="usage"><code>(poly-repeating state first-step n-times fn-transitions)</code><code>(poly-repeating state first-step n-times fn-transitions on-complete)</code></div><div class="doc"><pre class="plaintext">Union of `repeating` and `poly`. Returns a poly-transition repeating `n-times`.
</pre></div></div><div class="public anchor" id="var-remove-data"><h3>remove-data</h3><div class="usage"><code>(remove-data state data-path)</code><code>(remove-data state data-path _percent)</code><code>(remove-data state data-path _completion-step _step)</code></div><div class="doc"><pre class="plaintext">Uses `dissoc-in` for removing what is at some data-path.

More useful when used as an `on-complete` function and the data needs to be cleaned once the transition completes.</pre></div></div><div class="public anchor" id="var-remove-pre-data"><h3>remove-pre-data</h3><div class="usage"><code>(remove-pre-data state data-path)</code><code>(remove-pre-data state data-path _percent)</code><code>(remove-pre-data state data-path _completion-step _step)</code></div><div class="doc"><pre class="plaintext">A vast majority of modeling involves some form of entities. It is also very common for such entities to be removed once all
their transitions completes, meaning they cannot evolve anymore. This function, used as an `on-complete` function, does exactly that.

For instance, modeling asteroids as {:asteroids {42 {:x 542
                                                     :y 1000}}} having :x and :y transitions.

Once it cannot move anymore, an asteroid must be cleaned (ie. removed from the state). By providing this function as an `on-complete`
function to every :x and :y transition garantees that. It will use `dissoc-in` for removing [:asteroids 42] once it does not have
any transitions anymore.</pre></div></div><div class="public anchor" id="var-remove-transition"><h3>remove-transition</h3><div class="usage"><code>(remove-transition state data-path)</code><code>(remove-transition state data-path _percent)</code><code>(remove-transition state data-path _completion-step _step)</code></div><div class="doc"><pre class="plaintext">Removes a transition given the data-path.
</pre></div></div><div class="public anchor" id="var-repeating"><h3>repeating</h3><div class="usage"><code>(repeating first-step n-times n-steps on-step)</code><code>(repeating first-step n-times n-steps on-step on-complete)</code></div><div class="doc"><pre class="plaintext">Returns a transition repeating `n-steps` steps `n-times` times.
</pre></div></div><div class="public anchor" id="var-scale"><h3>scale</h3><div class="usage"><code>(scale scaled-a scaled-b percent)</code><code>(scale scaled-a scaled-b a b x)</code></div><div class="doc"><pre class="plaintext">3 args : scales a `percent` value to a value between `scaled-a` and `scaled-b`.

5 args : scales the `x` value between `a` and `b` to be between `scaled-a` and `scaled-b`.


Ex. (scale 0
           1000
           0.5)

    =&gt; 500


    (scale 0
           1000
           0
           100
           50)

    =&gt; 500</pre></div></div><div class="public anchor" id="var-step-key"><h3>step-key</h3><div class="usage"></div><div class="doc"><pre class="plaintext">When using `move-events`, each event must have a step assigned by this key.
</pre></div></div><div class="public anchor" id="var-transition-key"><h3>transition-key</h3><div class="usage"></div><div class="doc"><pre class="plaintext">All transitions belonging to a state must be under this key.
</pre></div></div><div class="public anchor" id="var-transition-path"><h3>transition-path</h3><div class="usage"><code>(transition-path data-path)</code></div><div class="doc"><pre class="plaintext">Given a data-path, returns a transition-path
</pre></div></div><div class="public anchor" id="var-without-transitions"><h3>without-transitions</h3><div class="usage"><code>(without-transitions state)</code></div><div class="doc"><pre class="plaintext">Returns the given state without its transitions.
</pre></div></div></div></body></html>